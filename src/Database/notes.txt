JDBC API - часть JDK
JDBC DRIVER - реализация JDBC  API для конкретной базы

строка в базе === обьект в java

Ключи есть сложеные(unique(firstName, lastName)), натуральные(unique (email)), дефолтные(unique (id))

Разные реляционные базы данных имеют свой диалект. Они все используют SQL, но фишки работы с ним добаляют все разные.

DB - сервер, который принимает реквесты в SQL, и отдает обратно какие-то значения, результат

SQL = DDL(меняют структуру базы данных) + DML(меняют данные, но не меняют стуктуру).

==== DB to Java JDBC API ====
DB                      JAVA JDBC API
database                DataSource.class
db connection           Connection.class
SQL query               Statement.class  ---> PreparedStatement - параметризованый SQL statement который имеет ряд преимуществ:
                                              1) Можно передавать параметры вместо "?"
                                              2) Компилируется базой данных и кешируется. При следующем выполнении этого же запроса будет просто
                                              подставлять разные значения в параметры.
                                              3) защищает от sql атак (вместо ? нельзя поставить DROP и тд.)
query result            ResultSet.class  ---> ResultSet - своего рода итератор, у которого есть метод next() который при каждом его вызове ResultSet
                                              будет переходить на новую строку.

DAL --> domein model --> Class(entity, model) которые не имеют бизнесс логики.

DATA --> MODEL
Account (data)
AccountDao (data manipulation)

==== DB design =====
придерживаться, того что нейвинг конвеншн должен быть одинаков у всех таблиц.

Java                        SQL
int                         int
long                        bigint
String                      varchar()
LocalDate                   date
LocalDateTime               timestamp
BigDecimal                  decimal / money

==== СВЯЗИ ====
1 - 1           ----> есть обязательная связь (пользователь(not null) - адресс(not null)),
                      может быть необязательная (пользователь(not null) - профайл(null)).
                      Связь всегда сохраняется на стороне child.
                      1) Если child независима и может существовать сама по себе, то эта сущность должна иметь свой pk + unique foreign key references parent(id)
                      2) Если child не может существовать сама по себе без parent (например пасспорт не может существовать без человека),
                      тогда у этого child будет (pk, foreign key) references parent(id)

1 - m           ----> Foreign key на стороне child references parent(id), но не unique!!!
                      Еще нужно думать по бизнесс логике может ли этот констрейнт быть вообще не присоединенным к parent (быть null)
                      например Комментарий не может существовать без видео -> ставим foreign key NOT NULL,
                      а футболист без команды может существовать, а потом можно его присоединить --> ставим foreign key NULL

m - m           ----> Пример: актер может иметь много фильмов и фильм может иметь много актеров.
                      Тогда создаем 3 таблицу. называем ее actor_movie, добавляем туда 2 колонки
                      1) actor_id references actor.id
                      2) movie_id references movie.id
                      После этого делаем композитный ключ для этих колонок PK(actor_id, movie_id)

==== Транзакции ====
Транзакция будет транзакцией если выполняется ACID. Транзакция должна иметь эти свойства что бы осуществлять корректную работу с БД.
Atomicity - атомарность             ----> Транзакция должна выполнятся полностью или не выполняться вообще.
Consistency - консистентность       ----> 1 транзакция должна переводить систему из 1 консистентного состояния в другое.
                                          Консистентное состояние - все данные взаимосогласованы (правильны)
Isolation - изоляция                ----> 1 транзакция не должна мешать другой транзакции
                                          (транзакции которые выполняются в несколько потоков должны дать такой же результат, который даст
                                          при выполнении транзакций не параллельно, а выполняясь 1 за другой)
Durability - долговечность          ----> Апаратные ошибки не фейлят закомиченные транзакции. (проблемы с железом)

По дефолту автокомит. что бы сделать ручной старт транзакции надо прописать:
START TRANSACTION
    QUERY
COMMIT ----> сохранит все изменения в транзакции

ROLLBACK ----> откатит все изменения в транзакции

1) select видит данные в конкретной транзакции. Если запустить из другого места, то видно не будет данных которые изменяются,
но не были еще закомичены.

Транзакции могут данные менять, могут данные читать. Разделяют на ReadWrite, ReadOnly.
START TRANSACTION;
SET TRANSACTION READ ONLY/WRITE;
COMMIT;
Для всех методов, где мы данные читаем транзакции должны быть ReadOnly.

==== LOCKS ====
В postgresql существует жетский лок на обновление таблицы. когда транзакция стартанула, выполнила обновление таблицы и транзакция не закомичена,
то мы не можем сделать select из другой транзакции, пока эта транзакция с апдейтом не будет закомичена. Срабатывает лок на апдейт таблицы.
Этот лок заблочит всю таблицу (все что читает и записывает в эту таблицу). Потому что это изменение структуры таблицы.
START TRANSACTION
ALTER TABLE table_name ADD COLUMN column type;
COMMIT

Под капотом постгреса есть много разных локов. В разных ситуациях он ставит разный лок в зависимости от того что ему нужно сделать.

==== TRANSACTION ISOLATION LEVELS ====
1) READ UNCOMMITED          ----> Позволяет читать не закомиченные данные (1 транзакция стартует и добаляет строку, другая транзакция делает
                                  select и видит эту строку. но строки нет в БД пока не будет комита.
                                  В постгресе этот уровень изолированости недоступен.

2) READ COMMITED            ----> Условие: не можешь читать не закомиченные данные. Можешь прочитать только то, что уже закомичено.

3) REPEATABLE READ          ----> В рамках одной транзакции один и тот же селект должен возвращать один и тот же результат.
                                  Даже если в другой транзакции было обновление этой строки которую мы читаем в своей транзакции.

4) SERIALIZABLE             ----> последовательное выполнение транзакций одна за одной.

Каждый из уровней транзакции задает дефолтное поведение транзакции. (под капотом на строки с которыми мы работаем в своих запросах налаживаются
определенные локи. Каждый из уровней изолированости транзакций использует разные локи. Чем больше уровень, тем жестче уровень используется под капотом.

==== ORM. JPA. HIBERNATE ====
ORM - object relational mapping. Что бы каждый раз не работать с БД на прямую(в реляционной модели), а работать в обьектно-ориетированной
есть орм фреймворк, который решает проблему несоответсвие между обьектной и реляционной моделью.

Проблемы несоответствия
OO                                           Relational
-assotiations       ----> list a ---->       foreign key not uqie references table
-identity           ----> == or equals() --> primary key
-navigations        ----> get().get() -->    join
-granularity        ----> class A{class B}   table b(foreign key table a)

JPA - спецификация ORM фреймворка в JAVA
Hibernate - реализация JPA. ORM фреймворк который решает несоотвествия обьектной и реляционной модели, позволяет работать с БД в обьектно-ориентированой
модели и превращает изменение состояния обьектов в DML.

            JPA
Configs(Connection)       Mapping (OO - RM)
            DAL (hibernate)

JPA - Entity manager.class ----> потоконезащищенный класс. на 1 запрос у нас вылделяется 1 entity manager (1 entity manager на 1 поток(для 1 юзера))
Hibernate - Session.class ---->

Для того что бы в приложении в много потоков пользователи могли получать entity manager instances есть (EntityManagerFactory/ SessionFactory) фабрика которая потокозащищенная
Фабрика нужна для тог что бы получать entity manager instances и она может работать с большим количеством потоков (в приложении
1 EntityManagerFactory и раззные потоки для разных пользователей будут на нем вызывать Persistence.createEntityManager() и оно будет им раздавать разные потоки)

==== JPA Entity Mapping ====
@Entity
@Id ---> generated value (INDENTITY --> autoincrement column)
@Table
@Column --> nullable

==== Persistence Context ====

Hibernate контролирует состояние наших ентити и в некоторых случаях превращает изменения состояния наших ентити в sql запросы (позволяет сохранять, удалять, менять и тд.)
Делает он это не со всеми обьектами где-нибудь в приложении, а только в рамках PersistenceContext.
PersistenceContext - контекст в рамках которого hibernate управляє, керує станом нашої ентіті.
----
| EntityManager(JPA)/ Session(Hibernate) (create)
| Transaction
| Transaction
|
| EntityManager(JPA)/ Session(Hibernate) (close)
----

==== Entity states ====
- NEW (TRANSIENT) ----> new Object()
                        (no id, is not in db, not in PC)

- PERSISTENT ----> addToDatabase(). Обьект который мы сохранили в базу или вытащили из базы, но он еще находится в рамках PersistenceContext
                   (has id, is in Database, is in PersistenceContext). Менять обьект можно только тут. Если в другом месте, то обьект не будет записан в базу с изменениями

- DETACHED ----> Например после метода close().
                 has id, is in db, not in PersistenceContext.

- REMOVED ----> has id. Но не имеет записи в базе данных.

NEW -----> PERSISTENT = entityManager.persist(obj)
PERSISTENT ------> DETACHED = entityManager.close(obj)
PERSISTENT ------> REMOVED = entityManager.remove(obj)

DETACHED -----> REMOVED = нельзя такого сделать. Что бы detached переместить в removed, нужно сначала сделать его persistent:
DETACHED -----> REMOVED = entityManager.merge(obj)

==== Dirty checking ====
update в базу данных хендлиться хибернейтом с помощью dirty checking.
Dirty checking работает только в рамках PersistenceContext и отвечает только за UPDATE

В рамках PersistenceContext Hibernate проверяет меняется ли наша ентити, если она меняется, то он шлет в базу данных UPDATE.

Как работает DirtyChecking:
В момент когда ентити загружается в PersistenceContext, создается ее снепшотная копия которая выглядит как массив обьектов
которому каждый элемент соответствует строке в базе данных. Для каждой ентити создается такой массив в котором сохраняются ее значения.
В конкретный момент (AT FLUSH TIME - момент, в который SQL посылает свои запросы) выполняется проверка каждого поля ентити с значением которое есть в снепшотной копии, и если какое-то значение изменилось,
то генирируется UPDATE.

Можно выключить DirtyChecking во всех местах где мы делать только select и не делаем update.
Мы должны его выключить потому что по дефолту он включен.
Выключить потому что он занимает много памяти (каждый раз создавать много копий и ходить проверять перед каждым запросом). ReadOnly.

==== DB design ====
1 - 1 ---> @OneToOne -------> Если ребенок зависит от предка, то это лучше для Hibernate. Это позволяет имяя 1 айдишник выгружать как родителя,
                              так и ребенка сразу. Ентити в PersistenceContext хранятся по айдишнику. Для того что бы ентити стала в стейт персистент
                              или менеджед (прилинкована к персистент контекст) у нее должна быть как минимум айдишка. Остальные поля могут быть
                              еще не загружены, может даже еще не сохранена в БД, но она уже может быть в PersistenceContext связана по айдишке.
                              Перед тем как сохранять ентити в БД у ентити должна быть хотя бы id!!!!
                              Если ребенок зависит от предка:
                              class User {
                                @OneToOne(mappedBy="user")
                                UserProfile userProfile;
                              }
                              class UserProfile {
                                @Id
                                Long id;
                                @MapsId
                                @OneToOne
                                User user;
                              }

1 - m ---> @OneToMany ------> Маппинг в хибернейте так же как и в SQL мы задаем на стороне child.
                              Пример: Видео и комменты к нему. Связь One to many. Видео 1 - комментов к нему много.
                              parent: video. child: videoComment. Значит делаем маппинг на стороне child.
                              Ставим аннотацию @ManyToOne + ставим @JoinColumn(name = "video_id") название колонки по которой происходит связь в БД.
                              Идем в parent и ставим там @OneToMany(mappedBy="video")
                              class Video {
                                @OneToMany(mappedBy="video")
                                List<VideoComment> comments;
                              }
                              class VideoComment {
                                @JoinColumn(name = "video_id")
                                @ManyToOne
                                Video video;
                              }

                              Бывают
                              1) Unidirectional - когда мы на одной стороне мапим. Например когда класс VideoComment знают про видео и в нем есть поле
                              типа Video, а в классе Video нет поля с типом VideoComment.
                              2) Bidirectional - когда с двух сторон классы знают про друг друга.
                              Video имеет приватное поле VideoComments. И VideoComments имеет приватное поле Video.

                              Итак, когда мы создаем Unidirectional, то мы мапим только на стороне child.
                              Если нужно на стороне child, то это Bidirectional.
                              Думать нужно так: если parent нужно делать getChilds(), то делаем Bidirectional.
                              Если не нужно, то делаем Unidirectional на стороне child.

m - m ---> @ManyToMany        1) @ManyToMany                            @ManyToMany
                                 @JoinTable()@JoinColumns()             mappedBy
                                                                                                2) @OneToMany(class1)         @OneToMany(class2)
                                                                                                                    @ManyToOne
                                                                                                                    @ManyToOne
                                                                                                                    (link class)
                              HashCode должен быть одинаковым при стейтах NEW, PERSISTENCE.
                              Не использовать айди в качестве хешкода когда @ManyToMany с двух сторон и с двух сторон Set
                              Можно использовать константный хешкод.

Обычно для генерации айдишок используются sequence (последовательность в БД). Можно создать через sql (create sequence), назвать и задать ему инкремент.

==== Fetch type ====
Хибернейт не может вытянуть сразу все по video.getComments(), потому что он вытянет всю базую. Для решения этой проблемы есть lazy loading
В хибернейте есть дефолтные настройки по которым он вытягивает данные. На это вестись нельзя, нужно контролировать все самим.
==== Lazy loading ====
Lazy initialization - означает, что мы сразу ентити не вытягиваем.
Как set.getComments() в ентити делает селект с базы??? ----> Что бы реализовать механизм lazy loading хибернейт использует прокси.
По дефолтуц хибернейт использует рантайм прокси.
Прокси - это когда у нас есть обьект, мы создаем для него другой обьект в котором создаем дополнителььную логику.
например перед геттером выполнить какую-то логику или после геттера выполнить.
Но хибернейт не создает прокси наших ентити и так не работает.
Он в момент когда загружает нашу ентити в PersistenceContext, в поле где хранятся комментарии(в нашем случае set)
сетит другу имплементацию коллекции Set, которая называется PersistenceSet.
В лист он засетит PersistenceList.
Поэтому надо создавать поля в интерфейсах, чтобы хибернейт смог подставить свою реализацию.
Для @...ToMany связей сеттеры для своих коллекций мы делаем private.
Для @...ToOne(fetchType=Lazy) тут уже нет коллекций, поэтому хибернейт создаст рантайм прокси для этого поля и засетит в это поле райнтайм прокси.

                                            Fetch Type
Lazy - говорит не вытягивать сразу данные                    Eager - говорит вытягивать срвзу данные
по дефолту: @OneToMany, @ManyToMany                          по дефолту: @OneToOne, @ManyToOne
(когда выгружаешь видео, то сразу                            (Когда выгружаешь комментарий, то выгружается сразу вместе с ним видео)
комментарии выгружаться не будут)                            Делаем findVideoById(1L):
Делаем findVideoById(1L):                                    если стоит Eager, то по поиску видео, будет селект через left join и вытянет все
если стоит Lazy,                                             комментарии для этого видео, и если у это комментари есть еще поле с Eager,
то select from comments не будет.                            то его тоже вытянет автоматически через еще один left join и так далее с вложеными полями
select from comments будет только тогда, когда               Eager.
мы сделаем video.getComments().                              Опасность Eager в том, что если ты пишешь обычный запрос руками, а не юзаешь findBy...,
                                                             то хибернейт все равно посмотрит на маппинг, выгрузит твой запрос, а потом выгрузит еще
                                                             селекты для полей Eager.
                                                             Что бы указать явно fetch, то в запросе можно написать "join fetch" users.

Правильно делать так: Пишем везде Lazy, а потом если нам надо выгрузить что-то с lazy,
пишем метод в котом есть запрос с join fetch который правильно вытянет данные 1 запросом.

Parent(1) ------- Child(m)
Если у нас UniDirectional, то все ок. Мы просто делаем child.addParent(parent) и все. Хибернейт это понимает, потому что у нас есть связь в БД.
Если у нас Bidirectional, тогда у parent появляется поле child, но связи в БД такой нет, которая ссылается на child.
Если сделать parent.addChilds(child) хибернейт этого не поймет.
Поэтому, нужно делать сеттеры с двух сторон. При чем хибернейт что бы отобразить эту свзь использует только child сторону.
Примеры:
1) Делаем video.getComments().addComent(comment) это мы делаем сет только с одной стороны,
теперь нам нужно этому комментарию засетить это видео comment.setVideo(video).
2) Тоже самое с remove. video.getComments.remove(comment) это только с одной стороны. Нужно еще сделать comment.setVideo(null).
В Bidirectional мы должны обеспечивать изменеие с двух сторон всегда!!!! Поэтому появляютсяч хелпер методы.
Хелпер методы мы реализуем с одной стороны (чаще всего на стороне parent)
private void addComment(Comment comment) {
    this.comments.add(comment);
    comment.setVideo(this);
}v
private void removeComment(Comment comment) {
    this.comments.remove(comment);
    comment.setVideo(null);
}

Алгоритм маппинга:
1) Создая маппинг мы связь мапим на стороне child, потому что на стороне child мы созраняем foreign key.
2) Если Unidirectional, то все ок. Если Bidirectional, то реализуем хелпер методы. + должен быть mappedBy поле на стороне child.
3) В маппинге отдаем предпочтение Lazy связям. потому что Lazy - overridable и мы можем его изменить через методы с запросами используя в них join fetch.
Оператор fetch говорит что нужно просетить поля(выгрузить в обьект), оператор join говорит что нужно соединить.
4) Lazy loading работает с помощью проксирования классов если мы используем @lazyToOne. Если используем @lazyToMany то работают PersistenceCollection.
Lazy loading работает только в рамках PersistenceContext
5) Lazy initialization exception вылетает тогда, когда к ентити, к ее lazy relation обращаются за рамками сессии.
6) N + 1 пробема. возникает в результате генерации большого количества select запросов в результате lazy связи.
N - потому что для каждой ентити делаем select. +1 - потому что мы сначала вытягиваем все ентити, а потом для lazy поля делаем еще дополнительный select.
(Вытягиваем видео ОК. Для этого видео .getComments() делаем еще селект).

==== Cascade. ManyToMany ====
Cascade - возможность копировать операцию от ентити к ее релейшену. Указывает тип операции которую мы будем копировать.
Например если мы используем каскад тип persist, это означает, что мы говорим про операцию persist.
Означает что персисте компании эта операция персист будет копироваться для ее продуктов. будет созранятся компания и продукты.
Если укажем каскад тип ремувд, эта операция будет копироваться. Если скажем ремув компания, то будут ремуваться вместе с ней ее продукты.
Если не использовать каскад, то у нас есть некоторые ограничения.
Например мы сохраняем автора и новую книжку. Мы не можем сразу сохранить нового автора и новую книжку в хибернейте если не использовать каскад.
Нужно будет сохранить автора, потом сохранить книжку с foreign key на этого автора. или наоборот.
Но с каскадом на пресист будет автоматический инсерт двух енитити (используется на авторе и расширяется на книжку). или наоборот.
Пример с видео и комментариями. Когда удаляем видео, можно поставить каскад ремув на удаление комментариев.
