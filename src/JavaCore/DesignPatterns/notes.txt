Так уже прийнято, що усі дизайн-патерни поділені на три великі групи, а
саме: породжуючі, структурні та поведінкові.

1) Породжуючі патерни. 
Основним завданням таких патернів є спростити створення об’єктів.

---Абстрактна фабрика - надає простий інтерфейс для створення об’єктів,
які належать до того чи іншого сімейства.

---Будівельник - вимальовує стандартний процес створення складного
об’єкта, розділяючи логіку будування об’єкта від його представлення.

---Фабричний Метод вирішує, яку реалізацію інстанціювати. Вирішують
або нащадки фабричного методу, або він сам, приймаючи якийсь
параметер.Якщо в метод передаються параметри, від яких залежить, який клас буде створено, то такий
Фабричний Метод називають Параметризованим Фабричним Методом.

---Прототип - дозволяє нам створювати копії об’єктів, що уже визначені на
стадії дизайну (наприклад, список можливих типів зустрічей) або ж
визначаються під час виконання програми («п’ятнична вечірка»), таким
чином, відпадає необхідність заповняти всі елементи об’єкту від «А» до
«Я». Вже створені або визначені екземпляри об’єкту називаються
прототипічними екземплярами (prototypical instances).1

---Одинак - забезпечує існування єдиного екземпляру класу та єдиного
доступу до нього.

2) Структурні патерни. 
Основним завданням структурних патернів є формування найбільш підходящої структури та взаємодії між класами для виконання певних завдань.

---Адаптер - якщо потрібно, щоб один об’єкт міг бути зрозумілим під іншим
інтерфейсом. Адаптер надає можливість користуватися об’єктом, який не є
прийнятним у нашій системі і який не можна змінити. Ми адаптуємо
його функціональність через інший, відомий нашій системі,
інтерфейс.

---Міст - якщо ви хочете розділити абстракцію та імплементацію так, що на одному
боці ви матимете абстракцію, а на іншому декілька реалізацій, причому, всі
доступні до модифікацій. Міст дозволяє розділити імплементацію від її абстракції, таким чином
реалізація може бути змінена окремо від абстракції, оскільки вона не
наслідується від неї напряму.

---Компонувальник - якщо елемент містить собі подібні елементи, а вони, в свою чергу, також
можуть містити елементи. Компонувальник дозволяє нам зберігати деревовидну структуру і
працювати однаково із батьками та синами у дереві.

---Декоратор - для швидкої та динамічної можливості розширення існуючої
функціональності, без зміни її носія. Декоратор використовується для надання деякої додаткової
функціональності нашим об'єктам.

---Фасад - надає єдину «точку доступу» до підсистеми, тим самим
спрощуючи її використання та розуміння.

---Легковаговик - якщо ваша система використовує багато об’єктів, що мають спільні дані, то
такі дані можна винести та зробити загальнодоступними для економії пам’яті. Легковаговик забезпечує підтримку великої кількості об’єктів шляхом
виокремлення спільної інформації для збереження в одному
екземплярі.

---Проксі - якщо відсутня можливість працювати із об’єктом напряму. Проксі підміняє реальний об'єкт та надсилає запити до нього тоді,
коли це потрібно. Проксі також може ініціалізувати реальний об'єкт,
якщо він до того не існував.

3) Паттерни поведінки
Патерни поведінки акцентують свою увагу на поведінці.
Вони або інкапсулюють поведінку, або дозволяють її розподілити.

---Ланцюжок відповідальностей - щоб забезпечити почергову передачу роботи від одного класу до іншого і
так далі, аж до поки робота не буде виконана. Ланцюжок Відповідальностей забезпечує обробку об’єкта шляхом передачі його по ланцюжку доти, доки не буде здійснена обробка
якоюсь із ланок.

---Команда - дозволяє інкапсулювати всю інформацію, необхідну для
виконання певних операцій, які можуть бути виконані пізніше,
використавши об’єкт команди.

---Інтерпретер - дозволяє описати граматику певної мови, за допомогою
чого можна записати речення на цій мові та інтерпретувати його
значення.

---Ітератор - дозволяє доступатися почергово до елементів будь-якої
колекції без вникання в суть її імплементації.

---Медіатор - централізує взаємодію між компонентами, таким чином
послаблюючи їхню зв’язність.

--Хранитель(memento) - використовується тоді, коли ви хочете відмінити операції
без відображення внутрішньої структури Хазяїна (Originator — гра у
нашому прикладі). Координація операцій здійснюється Опікуном
(Caretaker — контроллер гри), який надає можливість простого
збереження миттєвих станів системи без уявлення що ці стани собою
являють.

---Спостерігач - дозволяє автоматично реагувати багатьом об’єктам на
зміну стану певного іншого об’єкта.

---Стан - дозволяє винести логіку визначення стану об’єкту та його
поведінку, характерну для цього стану, в інші класи.

---Стратегія - зберігає сім’ю алгоритмів і дозволяє змінювати їх незалежно
та переключатися між ними.

---Шаблонний Метод - задає покроково алгоритм, а елементи алгоритму
можуть бути довизначені в похідних класах.

---Відвідувач (Visitor) -  дозволяє відділити певний алгоритм від
елементів, на яких алгоритм має бути виконаний, таким чином ми
можемо легко додати або ж змінити алгоритм без змін до елементів
системи. Як на мене, це і є однією із найбільш помітних переваг цього
патерну